/*
	1. 컴퓨터의 CPU의 가장 기본적인 구조는 가산기(Accumulator 더하기 전용 장치)이다
	그러므로 더하기, 곱하기 연산을 가장 잘한다
	--> 행렬은 선형연산으로 이루어진 식들의 계수를 나타낼 수 있다
	<-- 그러므로 스칼라들을 나열한 행렬이 컴퓨터가 처리하기 적합한 수학적 구조물이다

	2. 행렬은 컴퓨터에 배열 형태로 메모리를 만들어 다루기 적합한 형태의 수학적 구조물이다

	CPU는 정수 타입을 대상으로 만들어진 중앙 연산 처리장치 이다

	
좌표계(Coordinate system) : 물체의 위치를 유일하게 지정하기 위한 체계
	
	- 직교좌표계(Cartesian Coordinate system) : 원점에서 서로 직교하는 축으로 이루어진 좌표계

	2D (x,y) : 두 축으로 이루어진다
	3D (x,y,z) : 세 축으로 이루어진다
	

	- 엄지 : x축 / 검지 : y축 / 중지 : z축
	
	왼손 좌표계 : z축이 안쪽을 향해 증가한다
	오른손 좌표계 : z축이 안쪽을 향해 감소한다

	극좌표계(Polar Coordinate system) (r, A) : 극(pole)이라는 기준점을 두고 이것을 기준으로 각도와 거리로 위치를 나타내는 좌표계
	
	직각좌표 -> 극좌표 변환공식
	(sqrt(x^2+y^2), atan2(y,x))

	극좌표 -> 직각좌표 변환공식
	x = r cosA
	y = r sinA

삼각함수

	두 점(위치)를 알때
	임의의 크기의, 임의의 방향의 벡터 구하기 = 목적지점 - 시작지점

	AxB = ||A||*||B||*sinA*U --> U는 A와 B에 모두 수직인 단위벡터

	삼각형의 세 점으로 세 개의 벡터를 만들고 그 벡터들을 두 개씩 짝지어 외적을 구하면 모두 같은 외적벡터가 나온다
	--> 삼각형의 세 점은 한 평면위에 있음이 수학적으로 보장된다
	<-- 그러므로, 3D 모델의 가장 기본 최소단위가 될 수 있다


벡터 : 크기 + 방향을 아우르는 개념
(vs 스칼라 : 크기)

	표기법
	->	수벡터(Numerical vector)
			실수의 순서쌍으로 표현 -> (x, y) (1,0)

	->	기하벡터(Geometry vector)
			위치 + 연산이 통합되어 있다
	선형종속

	선형독립
	기저(basis) : 서로 선형독립인 기저벡터들의 집합

	차원(dimension) : 기저를 구성하는 기저벡터의 개수
		2차원 - 서로 직교하는 벡터 i, j 로 공간의 모든 벡터들을 표현할 수 있다
		3차원 - 서로 직교하는 벡터 i, j, k 로 공간의 모든 벡터들을 표현할 수 있다
	
	단위벡터(unit vector) : 크기가 1인 벡터
		X * 1 = X , X + 0 = X
		--> 1, 0 = 항등원
	
	법선벡터(Normal vector) : 수직인 벡터
		2D : 어떤 벡터에 수직인 벡터
		3D : 어떤 평면에 수직인 벡터
	<-- 그래픽스 프로그래밍에서 평면은 대수적으로 법선벡터로 정의된다

	연산 : 임의의 두 개의 수학적 구조물을 기반으로 하나의 결과를 만들어 내는 동작 (1 + 1 = 2)
	--> 수학적 구조물의 정체성을 밝히는 도구

	벡터의 연산
		1. 벡터끼리의 덧셈(뺄셈)
			각각의 구성성분끼리 더한다

			A = (1,0), B = (0,1)
			A + B = (1,0) + (0,1) = (1+0, 0+1) = (1,1)

		2. 벡터의 스칼라곱
			벡터의 각각의 구성성분에 스칼라를 곱한다

			A = (1,0), S = 2
			A * S = (1,0)*2 = (1*2, 0*2) = (2,0)

		벡터끼리의 곱셈
		3. 내적
			내적의 결과값은 스칼라다

			A = (1,0), B = (0,1)
			A.B = ||A|| ||B|| cosT
				=   1  *  1  * 0		= 0

				= A.x * B.x + A.y * B.y
				=  1  *  0  +  0  *  1  = 0

		4. 외적(cross product)
			: 교환법칙이 성립되지 않는다
			A = (1,0), B = (0,1)

			AxB = ||A|| ||B|| sinT U
			(U는 A와 B에 모두 수직인 단위벡터)

			A = (1,0, 0)
			B = (0,1, 0)
			U = (0,0, 1)

			// 3차원의 기저
			i = (1,0,0) // X축 기저벡터
			j = (0,1,0) // Y축 기저벡터
			k = (0,0,1) // Z축 기저벡터

			AxB = ||A|| ||B|| sinT U
				=   1  *  1  * 1 * (0,0,1) = (0,0,1)
				= (A.y*B.z - A.z*B.y)*i + (A.z*B.x - A.x*B.z)*j + (A.x*B.y - A.y*B.x)*k
				= (0*0 - 0*1)*i + (0*0 - 1*0)*j + (1*1 - 0*0)*k
				= (0,0,0) + (0,0,0) + 1*k
				= (0,0,0) + (0,0,0) + 1*(0,0,1)
				= (0,0,0) + (0,0,0) + (0,0,1)
				= (0,0,1)


	배열 : 동일한 타입의 원소들의 연속적인 메모리 블럭
	<-- CPU 캐시 적중률이 올라간다

행렬(Matrix) : '행'과 '열'로 구성된 '격자' 모양의 '배열' 안에 '스칼라'들을 '나열'한 것
	- 행렬의 곱셈은 결합법칙이 성립한다(결합법칙 성립 O, 교환법칙 성립 X)

	어떤 연산이 선형(Linear <-- Line)이라면 그것은 행렬로 표현이 가능하며, 반대로 어떤 행렬은 어떤 선형연산으로 해석될 수 있다
	이러한 특성 때문에 컴퓨터 연산에서 매우 중요하다

	선형 연산 : +, * 연산자들로 구성된 대수식
	<-- 행렬의 유래에서 기인한다
	컴퓨터 <-- 계산기 <-- 가산기(Accumulator) : 더하기 장치

	게임 개발에서는 정사각행렬을 전제로 한다
	i = j (i행, j열)인 요소 -> 대각 요소(diagonal element)

	- 대각행렬(diagonal matrix) : 대각요소를 제외하고 모든 요소가 0인 행렬
	
	

	- 단위행렬(identity Matrix) : 모든 대각요소가 1인 대각행렬
		행렬끼리의 곱셈의 항등원

		정수의 곱셈의 항등원
		A * 1 = A	

	- 영행렬(zero matrix) : 모든 요소가 0인 행렬
		행렬끼리의 덧셈의 항등원

		정수의 덧셈의 항등원
		A + 0 = A

	- 역행렬
	  A * A^-1 = I

	  정수의 곱셈의 역원
	  : A의 곱셈의 역원
		A * (1/A) = 1

	- 전치행렬(transpose) : 대각성분을 축으로 하여 나머지 요소들을 서로 뒤바꾼다 (정사각행렬 전제)
		mxn 행렬 M에서 M의 i행 j열의 요소와 j행i열의 요소를 바꿔넣은 nxm행렬을 원래 행렬 M의 전치행렬 이라고 한다

	- 행렬식(determinant) : 행렬의 스칼라값을 얻을 수 있는 식
		

		2x2 행렬	 A = (a b)
					     (c d)
		1.			|A| = det A
						= ad - bc

		2. 여인수 전개(라플란스 전개)에 의한 행렬식 구하기
			1) 임의의 행이나 열을 하나 선택한다
			2) 해당 행이나 열에 속한 성분들을 계수로 삼는다
			3) + - + - 그대로 부호를 붙힌다

					|A| = det A
		(a b) 선택		= + a * d - b * c

		3x3 행렬	 B  = (1 2 3)
						  (4 5 6)
						  (7 8 9)
					|B| = det B
		(1 2 3) 선택	= + 1 * |5 6| - 2 * |4 6| + 3 * |4 5|
								|8 9|		|7 9|		|7 8|
						= 1*(5*9 - 6*8) - 2*(4*9 - 6*7) + 3*(4*8 - 5*7)
						= 1*(45-48) - 2*(36-42) + 3*(32-35)
						= - 3 - 2*(-6) + 3*(-3)
						= -3+12-9
						= 0
		--> 행렬 B의 행렬식이 0이므로 B의 역행렬은 없다

	행렬식의 값이 0이 나온다면 역행렬은 없다
	왜냐하면 역행렬 공식에 의하면 행렬식이 분모로 위치하고 있기 때문이다

	수학에서 0으로 나누는 것은 정의되어 있지 않다
	그러므로 역행렬 공식이 무의미해진다

	역행렬(행렬식의 역수) 공식
	A^-1 = (1/detA) * adjA

		adjA (수반행렬)
		1. 전치하고		<-- transpose
		2. 여인수한다	<-- 여인수 행렬을 구한다

			A = ( 1 2)
				(-1 3)
		A^-1 = (1/detA) * adjA		detA = | 1 2| = 3 - (-2) = 5
										   |-1 3|
									adjA = 1. ( 1 2)^T = (1 -1)
										      (-1 3)	 (2  3)
										   2. (  3  -2) = (3 -2)
											  (-1*-1 1)   (1  1)
			 = (1/5) * (3 -2) = (3/5 -2/5) = (1 0)
					   (1  1)	(1/5  1/5)	 (0 1)

	행벡터 : 1xn
	열벡터 : nx1
	(1xn)*(nxn) = (1xn)
	(nxn)*(nx1) = (nx1)
	(nx1)*(nxn), (nxn)*(1xn) : 계산불가

	스위즐연산

	특수직교행렬

*/